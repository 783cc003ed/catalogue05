## DuckDuckgo search -> docx BFS overflow
`2025-08-22`

* https://www.slideshare.net/slideshow/breadth-first-search-depth-first-search/87538912

<blockquote>
 BreadthFirstSearchDepthFirstSearchPPTXSlideShare
</blockquote>
<blockquote>
The document discusses two tree and graph traversal algorithms: Breadth First Search (BFS) and Depth First Search (DFS). BFS uses a queue to visit all nodes level by level, while DFS uses a stack to explore as far as possible along each branch before backtracking. It also compares the two algorithms in terms of speed, memory usage, and effectiveness in finding the shortest path. - Download as ...
</blockquote>

---

## DuckDuckgo search -> docx BFS overflow
`2025-08-22`

* https://stackoverflow.com/questions/8043095/should-i-use-breadth-first-or-depth-first-for-searching-a-filesystem-for-a-prede

<blockquote>
 ShouldIusebreadthfirstordepthfirstforStackOverflow
</blockquote>
<blockquote>
EDIT 2: Though is seems the popular answer is BFS for my problem, I am having trouble understanding why it would not be a DFS problem. Since (A) all errors need eventually be reached and (B) we know if a directory contains errors, BFS's protection against rabbit holes does not really apply.
</blockquote>

---

## DuckDuckgo search -> docx BFS overflow
`2025-08-22`

* https://codeforces.com/blog/entry/63971

<blockquote>
 QueueOverflowinBFSCodeforces
</blockquote>
<blockquote>
The memory limit is 16 MB. To solve this, I am using bfs with a circular queue of fixed size around 1.5e6. The whole thing (queue + grid) fits into the memory limit. For every non-visited 1, I am starting a bfs to cover all 1's in its component. The maximum number of cells in the queue at a time should be O (n+m).
</blockquote>

---

## DuckDuckgo search -> docx BFS overflow
`2025-08-22`

* https://www.slideshare.net/slideshow/breadth-first-search-depth-first-search/87538912

<blockquote>
 BreadthFirstSearchDepthFirstSearchPPTXSlideShare
</blockquote>
<blockquote>
The document discusses two tree and graph traversal algorithms: Breadth First Search (BFS) and Depth First Search (DFS). BFS uses a queue to visit all nodes level by level, while DFS uses a stack to explore as far as possible along each branch before backtracking. It also compares the two algorithms in terms of speed, memory usage, and effectiveness in finding the shortest path. - Download as ...
</blockquote>

---

## DuckDuckgo search -> docx BFS overflow
`2025-08-22`

* https://stackoverflow.com/questions/8043095/should-i-use-breadth-first-or-depth-first-for-searching-a-filesystem-for-a-prede

<blockquote>
 ShouldIusebreadthfirstordepthfirstforStackOverflow
</blockquote>
<blockquote>
EDIT 2: Though is seems the popular answer is BFS for my problem, I am having trouble understanding why it would not be a DFS problem. Since (A) all errors need eventually be reached and (B) we know if a directory contains errors, BFS's protection against rabbit holes does not really apply.
</blockquote>

---

## DuckDuckgo search -> docx BFS overflow
`2025-08-22`

* https://codeforces.com/blog/entry/63971

<blockquote>
 QueueOverflowinBFSCodeforces
</blockquote>
<blockquote>
The memory limit is 16 MB. To solve this, I am using bfs with a circular queue of fixed size around 1.5e6. The whole thing (queue + grid) fits into the memory limit. For every non-visited 1, I am starting a bfs to cover all 1's in its component. The maximum number of cells in the queue at a time should be O (n+m).
</blockquote>

---

